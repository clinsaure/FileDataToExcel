@page "/txtdata"

@using FileDataToExcel.Models
@using System.Diagnostics
@inject IJSRuntime JSRuntime


<PageTitle>File txt</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true" Align="Align.Center">EB TO EXCEL</MudText>

@inject ISnackbar Snackbar

<MudPaper @ondragenter="@SetDragClass" @ondragleave="@ClearDragClass" @ondragend="@ClearDragClass" Height="125px" Outlined="true" Class="@DragClass">
    @if (!Clearing)
    {
        <InputFile OnChange="OnInputFileChanged" multiple class="absolute mud-width-full mud-height-full overflow-hidden z-2" style="opacity:0;" accept=".EB, .txt" />
    }
    <MudText Typo="Typo.h6">Drag and drop files here or click MAX 10 FILES</MudText>
    @foreach (var file in loadedFiles)
    {
        <MudChip Color="Color.Dark" Text="@file.Name" />
    }
</MudPaper>

<MudProgressLinear hidden="@(!loadedFiles.Any())" Color="Color.Tertiary" Size="Size.Medium" Indeterminate="true" Class="my-7"/>

@*<MudToolBar DisableGutters="true" Class="gap-4">
    <MudButton OnClick="Upload" Disabled="@(!loadedFiles.Any())" Color="Color.Primary" Variant="Variant.Filled" StartIcon="@Icons.Filled.UploadFile" Class="mr-1">Upload</MudButton>
    <MudButton OnClick="Clear" Disabled="@(!loadedFiles.Any())" Color="Color.Error" Variant="Variant.Filled" StartIcon="@Icons.Filled.Clear">Clear</MudButton>
</MudToolBar>*@


<MudDataGrid T="TxtItem" MultiSelection="true" Items="@TxtItems" Sortable="true" Filterable="true" QuickFilter="@_quickFilter"
             Hideable="true" Hover="true" Dense="true" Bordered="true" Striped="true">
    <ToolBarContent>
        <MudText Typo="Typo.h6">EB TO EXCEL</MudText>
        <MudSpacer />
        <MudButton OnClick="ExportToExcel" Disabled="@(TxtItems.Count() <= 0)" Color="Color.Tertiary" Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.ArrowDownward" Class="mr-1">Excel Export</MudButton>
        <MudButton OnClick="ClearTable" Disabled="@(TxtItems.Count() <= 0)" Color="Color.Error" Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.Clear">Clear Table</MudButton>
        <MudSpacer />
        <MudTextField @bind-Value="_searchString" Placeholder="Search" Adornment="Adornment.Start" Immediate="true"
                      AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
    </ToolBarContent>
    <Columns>
        @*<SelectColumn T="TxtItem" />*@
        @foreach (var prop in props)
        {
            <Column T="TxtItem" Field="@prop" />
        }

    </Columns>
    <PagerContent>
        <MudDataGridPager T="TxtItem" />
    </PagerContent>
</MudDataGrid>


@code {

    private bool Clearing = false;
    private static string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    private string DragClass = DefaultDragClass;
    private List<IBrowserFile> loadedFiles = new();
    private string? _searchString;
    private List<string?> props = new();
    private List<TxtItem> TxtItems = new();


    protected override void OnInitialized()
    {
        foreach (var propertyInfo in typeof(TxtItem).GetProperties())
        {
            props.Add(propertyInfo.Name);
        }
    }


    private void OnInputFileChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        var files = e.GetMultipleFiles();
        foreach (var file in files)
        {
            //file.Name.Replace(" ", string.Empty);
            if (file.Name.Split(".")[1] == "EB" || file.Name.Split(".")[1] == "txt")
                loadedFiles.Add(file);
        }

        Upload();
    }

    private async Task Clear()
    {
        Clearing = true;
        loadedFiles.Clear();
        ClearDragClass();
        await Task.Delay(100);
        Clearing = false;
    }
    private async void Upload()
    {
        //Upload the files here

        //TxtItems.Clear();
        Snackbar.Configuration.PositionClass = Defaults.Classes.Position.TopCenter;
        int fileExist = 0;

        foreach (var file in loadedFiles)
        {
            Stream stream = file.OpenReadStream();
            MemoryStream ms = new MemoryStream();
            await stream.CopyToAsync(ms);

            stream.Close();
            var outputFileString = System.Text.Encoding.UTF8.GetString(ms.ToArray());

            String[] fileContents = outputFileString.Split("{SYSTEM ENTITY");

            fileContents = fileContents.Skip(1).ToArray();

            foreach (var fileContent in fileContents)
            {
                String[] strContents = fileContent.Split("}");

                strContents = strContents.Skip(1).ToArray();

                foreach (var strContent in strContents)
                {
                    TxtItem txtItem = new();

                    foreach (var prop in props)//foreach (var dEnum in Enum.GetValues(typeof(Datatxtenum)))
                    {
                        //results.Add(dEnum.ToString());

                        string pattern = string.Empty;
                        string dataPattern = string.Empty;

                        switch (prop)
                        {
                            case "POINTTYPE":
                                pattern = @"&T(.*)";
                                dataPattern = Regex.Match(strContent, pattern, RegexOptions.IgnoreCase).Groups[1].Value;
                                txtItem.POINTTYPE = dataPattern;
                                break;
                            case "TAGNUMBER":
                                pattern = @"&N(.*)";
                                dataPattern = Regex.Match(strContent, pattern, RegexOptions.IgnoreCase).Groups[1].Value;
                                txtItem.TAGNUMBER = dataPattern;
                                break;
                            default:
                                pattern = @"" + prop + "(.*)";
                                //pattern = @"" + prop + "";
                                StringComparison comp = StringComparison.OrdinalIgnoreCase;
                                Boolean result = strContent.Contains(prop, comp);
                                if (result)
                                {
                                    try
                                    {
                                        dataPattern = Regex.Match(strContent, pattern, RegexOptions.IgnoreCase).Groups[1].Value.Split("=")[1];
                                        txtItem.GetType().GetProperty(prop).SetValue(txtItem, dataPattern);
                                    }
                                    catch (Exception e)
                                    {
                                        //Snackbar.Add(e.Message, Severity.Error);
                                    }

                                }
                                else
                                {
                                    txtItem.GetType().GetProperty(prop).SetValue(txtItem, "");
                                }
                                break;
                        }

                    }

                    if (!TxtItems.Any(x => x.TAGNUMBER == txtItem.TAGNUMBER))
                        TxtItems.Add(txtItem);
                    else
                        fileExist++;
                }
            }
        }

        if (fileExist > 0)
            Snackbar.Add("" + fileExist + " File(s) already exist", Severity.Info);

        await Clear();

        this.StateHasChanged();
    }

    private void ClearTable()
    {
        TxtItems.Clear();
        this.StateHasChanged();
    }

    private void SetDragClass()
    {
        DragClass = $"{DefaultDragClass} mud-border-primary";
    }

    private void ClearDragClass()
    {
        DragClass = DefaultDragClass;
    }

    //private string stringBetween(string Source, string Start, string End)
    //{
    //    string result = "";
    //    if (Source.Contains(Start) && Source.Contains(End))
    //    {
    //        int StartIndex = Source.IndexOf(Start, 0) + Start.Length;
    //        int EndIndex = Source.IndexOf(End, StartIndex);
    //        result = Source.Substring(StartIndex, EndIndex - StartIndex);
    //        return result;
    //    }

    //    return result;
    //}


    // quick filter - filter gobally across multiple columns with the same input
    private Func<TxtItem, bool> _quickFilter => x =>
    {
        if (string.IsNullOrWhiteSpace(_searchString))
            return true;

        foreach (var prop in props)
        {
            if (x.GetType().GetProperty(prop).GetValue(x, null).ToString().Contains(_searchString, StringComparison.OrdinalIgnoreCase))
                return true;
        }

        return false;
    };

    public async Task ExportToExcel()
    {

        using (var workbook = new XLWorkbook())
        {
            IXLWorksheet worksheet = workbook.Worksheets.Add("System");
            var p = 1;
            foreach (var prop in props)
            {
                worksheet.Cell(1, p).Value = prop;
                p++;
            }


            for (int i = 1; i <= props.Count(); i++)
            {
                worksheet.Cell(1, i).Style.Font.Bold = true;
            }

            int index = 1;
            foreach (var txtItem in TxtItems)
            {
                int i = 1;
                foreach (var prop in props)
                {
                    worksheet.Cell(index + 1, i).Value = txtItem.GetType().GetProperty(prop).GetValue(txtItem, null);
                    i++;
                }
                index++;
            }

            using (var stream = new MemoryStream())
            {
                workbook.SaveAs(stream);
                var content = stream.ToArray();

                var fileName = "Output_TXT_Files_" + DateTime.Now.ToString("dd-MM-yyyy") + " .xlsx";
                await JSRuntime.InvokeAsync<object>("saveAsFile", fileName, Convert.ToBase64String(content));
            }
        }
    }
}


